<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>源码分析——客户端负载Netflix Ribbon - i蝸居年華_谢谢谢_CODE_HOME</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="[TOC] 前言Ribbon是由Netflix OSS开源的负载均衡组件"><meta name="keywords" content="微服务"><meta property="og:type" content="article"><meta property="og:title" content="源码分析——客户端负载Netflix Ribbon"><meta property="og:url" content="https://xiefayang.com/2019/04/23/源码分析——客户端负载Netflix Ribbon/index.html"><meta property="og:site_name" content="i蝸居年華_谢谢谢_CODE_HOME"><meta property="og:description" content="[TOC] 前言Ribbon是由Netflix OSS开源的负载均衡组件"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://blog-md-pic-1259135436.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/Ribbon%E7%BB%84%E4%BB%B6%E8%84%91%E5%9B%BE.jpg"><meta property="og:image" content="https://blog-md-pic-1259135436.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/RibbonLoadBalancerClient%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png"><meta property="og:image" content="https://blog-md-pic-1259135436.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/RoundRobinRule.png"><meta property="og:image" content="https://blog-md-pic-1259135436.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/RestTemplate%20intercaptor.png"><meta property="og:updated_time" content="2019-04-29T03:23:46.411Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="源码分析——客户端负载Netflix Ribbon"><meta name="twitter:description" content="[TOC] 前言Ribbon是由Netflix OSS开源的负载均衡组件"><meta name="twitter:image" content="https://blog-md-pic-1259135436.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/Ribbon%E7%BB%84%E4%BB%B6%E8%84%91%E5%9B%BE.jpg"><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?b59777544dd5d59ce94e191bac62427c";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"> <a class="navbar-item navbar-logo" href="/"><img src="/images/maotouying.svg" alt="源码分析——客户端负载Netflix Ribbon" height="28"> <span style="font-size:16px;display:inline-block;vertical-align:top;font-weight:600">i蝸居年華_谢谢谢</span></a></div><div class="navbar-menu"><div class="navbar-start"> <a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="文章目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><div class="box01"> <input type="text" id="tip" placeholder="You Know, for Search~"><i class="search_icon"></i></div></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-content article"><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"> <span style="color:#7a7a7a!important">写于2019-04-23 11:23:22&nbsp;&nbsp;&nbsp;</span><div class="level-item"> <a class="has-link-grey -link" href="/categories/微服务专题/">微服务专题</a></div> <span class="level-item has-text-grey">21 分钟 读完 (大约 3205 个字)</span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"> 源码分析——客户端负载Netflix Ribbon</h1><div class="content"><p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/Netflix/ribbon" target="_blank" rel="noopener">Ribbon</a>是由Netflix OSS开源的负载均衡组件<a id="more"></a></p><p>Spring Cloud将其整合作为客户端侧的(client-side)负载均衡组件, 以类库的形式集成于消费者客户端内</p><p>你在Spring Cloud整合Eureka, Feign, Zuul的组件中都可以见到它的影子</p><blockquote><p>关于负载的作用与分类模式可以参考: <a href="https://xiefayang.com/2019/04/19/服务发现——需求与模式/">服务发现——需求与模式</a></p></blockquote><p>在Netflix的场景中, Ribbon与Eureka都是作用在中间层的服务, 在终端接入侧的Edge Service负载仍然由亚马逊ELB服务提供</p><blockquote><p>AWS 弹性负载均衡服务是边界服务的负载均衡解决方案，边界服务是向终端用户访问 Web 而开放的。<br>Eureka 填补了中间层负载均衡的空缺。<br>虽然，理论上可以将中间层服务直接挂在 AWS 弹性负载均衡器后面，但这样会将它们直接开放给外部世界，从而失去了 AWS 安全组的所有好处。<br>—— 摘自Netflix</p></blockquote><p><br></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>阅读源码的目为了解决以下几个疑问</p><ul><li>Ribbon获取到服务列表后是如何负载? 如何路由到目标服务的?<ul><li><del>Ribbon中的负载均衡策略有哪些? —— 网上很多说明</del></li></ul></li><li>Ribbon是怎么获取/更新服务列表的?</li><li>Ribbon的工作流程</li><li>Spring RestTemplate是如何具备LB能力的, 它与Ribbon有什么联系</li></ul><p><br></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>版本:</p><p>Netflix Ribbon的<a href="https://github.com/Netflix/ribbon" target="_blank" rel="noopener">源码</a>依然是Servlet应用, 为了调试方便我还是在Spring Cloud的集成工程中, 源码仅作为参照方便查找</p><p>所以准确讲, 并不是单独分析, 而是Spring Cloud Netflix Ribbon</p><ul><li>Spring Cloud: <code>Finchley.SR2</code></li><li>对应Netflix Ribbon: <code>v2.2.5</code></li></ul><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> git checkout -b v2.2.5 v2.2.5</span><br></pre></td></tr></table></figure><p>名词:</p><ul><li>NIWS: Netflix Internal Web Service Framework</li></ul><p><br></p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p><img src="https://blog-md-pic-1259135436.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/Ribbon%E7%BB%84%E4%BB%B6%E8%84%91%E5%9B%BE.jpg" alt="Ribbon核心组件"></p><p>the beans that Spring Cloud Netflix provides by default for Ribbon:</p><table><thead><tr><th>Bean Type</th><th>Bean Name</th><th>Class Name (default)</th></tr></thead><tbody><tr><td><code>IClientConfig</code></td><td><code>ribbonClientConfig</code></td><td><code>DefaultClientConfigImpl</code></td></tr><tr><td><code>IRule</code></td><td><code>ribbonRule</code></td><td><code>ZoneAvoidanceRule</code></td></tr><tr><td><code>IPing</code></td><td><code>ribbonPing</code></td><td><code>DummyPing</code></td></tr><tr><td><code>ServerList&lt;Server&gt;</code></td><td><code>ribbonServerList</code></td><td><code>ConfigurationBasedServerList</code></td></tr><tr><td><code>ServerListFilter&lt;Server&gt;</code></td><td><code>ribbonServerListFilter</code></td><td><code>ZonePreferenceServerListFilter</code></td></tr><tr><td><code>ILoadBalancer</code></td><td><code>ribbonLoadBalancer</code></td><td><code>ZoneAwareLoadBalancer</code></td></tr><tr><td><code>ServerListUpdater</code></td><td><code>ribbonServerListUpdater</code></td><td><code>PollingServerListUpdater</code></td></tr></tbody></table><p>以上几个组件在源码分析过程会提到</p><p><br></p><h2 id="Ribbon核心源码"><a href="#Ribbon核心源码" class="headerlink" title="Ribbon核心源码"></a>Ribbon核心源码</h2><h3 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a><strong>调试代码</strong></h3><p>为了在方便调试源码, 我准备一个很简单的代码<br></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line"><span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();</span><br><span class="line">    ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="hljs-string">"HELLO-SERVICE"</span>);</span><br><span class="line">    String url = <span class="hljs-string">"http://"</span> + serviceInstance.getHost() + <span class="hljs-string">":"</span> + serviceInstance.getPort();</span><br><span class="line">    <span class="hljs-keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="路由-amp-负载"><a href="#路由-amp-负载" class="headerlink" title="路由 &amp; 负载"></a><strong>路由 &amp; 负载</strong></h3><h4 id="LoadBalancerClient"><a href="#LoadBalancerClient" class="headerlink" title="LoadBalancerClient"></a>LoadBalancerClient</h4><p>RibbonLoadBalancerClient作为Ribbon负载逻辑的重要实现类, 看它之前, 先来看看它的接口声明</p><ul><li>继承结构</li></ul><p><img src="https://blog-md-pic-1259135436.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/RibbonLoadBalancerClient%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="继承结构图"></p><ul><li><p>接口定义</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoadBalancerClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceInstanceChooser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function">URI <span class="hljs-title">reconstructURI</span><span class="hljs-params">(ServiceInstance instance, URI original)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceInstanceChooser</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="hljs-function">ServiceInstance <span class="hljs-title">choose</span><span class="hljs-params">(String serviceId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>解释:</p><p>LoadBalancerClient</p><ul><li><p><code>execute()</code>: 两个重载方法根据服务实例(serviceInstance)执行请求</p></li><li><p><code>reconstructURI()</code>: 重构URI</p><p>例如<code>http://cloudlink-user/priUser/getByIds</code>重构为<code>http://SC-201707142304:8802/priUser/getByIds</code></p></li></ul><p>ServiceInstanceChooser</p><ul><li><code>choose(String serviceId)</code>: 即依据LoadBalancer选择并返回服务ID对应的服务实例</li></ul><blockquote><p>源码中有比较详细的注释</p></blockquote><p>显而易见<code>RibbonLoadBalancerClient#choose</code>是应该重点分析的方法</p><p>它调用了<code>getServer()</code>方法, 经过几个函数重载, 最终调用了ILoadBalancer中的实现</p><p>默认的实现其实是<code>com.netflix.loadbalancer.ZoneAwareLoadBalancer#chooseServer</code></p><blockquote><p>—— 参考配置类: <code>RibbonClientConfiguration#ribbonLoadBalancer</code></p></blockquote><p>它是BaseLoadBalancer的子类, 因为我的环境只有一个可用区zone, 所以不会走区域相关的负载逻辑, 直接调用父类<code>super.chooseServer(key)</code>, 即<code>BaseLoadBalancer#chooseServer</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">chooseServer</span><span class="hljs-params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span> (counter == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">		counter = createCounter();</span><br><span class="line">	&#125;</span><br><span class="line">	counter.increment();</span><br><span class="line">	<span class="hljs-keyword">if</span> (rule == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">	&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">		<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">			<span class="hljs-keyword">return</span> rule.choose(key); <span class="hljs-comment">// look me !</span></span><br><span class="line">		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			logger.warn(<span class="hljs-string">"LoadBalancer [&#123;&#125;]:  Error choosing server for key &#123;&#125;"</span>, name, key, e);</span><br><span class="line">			<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IRule"><a href="#IRule" class="headerlink" title="IRule"></a><strong>IRule</strong></h4><p>接着上面的, 略过非重点代码, 看<code>rule.choose(key)</code></p><p>其中的<code>rule</code>就是Ribbon中负载均衡策略的核心接口IRule , 对应前面核心组件中提到的<strong>Rule—负载均衡策略</strong></p><p>接口定义如下:</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IRule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">choose</span><span class="hljs-params">(Object key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoadBalancer</span><span class="hljs-params">(ILoadBalancer lb)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ILoadBalancer <span class="hljs-title">getLoadBalancer</span><span class="hljs-params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>choose()</code>, 接口ILoadBalancer中定义了负载均衡器中的操作方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ILoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addServers</span><span class="hljs-params">(List&lt;Server&gt; newServers)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">chooseServer</span><span class="hljs-params">(Object key)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">markServerDown</span><span class="hljs-params">(Server server)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Deprecated</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Server&gt; <span class="hljs-title">getServerList</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> availableOnly)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Server&gt; <span class="hljs-title">getReachableServers</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Server&gt; <span class="hljs-title">getAllServers</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IRule的抽象子类AbstractLoadBalancerRule中完成了ILoadBalancer的<code>setter&amp;getter</code></p><p>回到<code>chooseServer()</code>中, 作为BaseLoadBalancer类的成员变量, 默认值定义如下:<br></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> IRule DEFAULT_RULE = <span class="hljs-keyword">new</span> RoundRobinRule();</span><br><span class="line"><span class="hljs-keyword">protected</span> IRule rule = DEFAULT_RULE;</span><br></pre></td></tr></table></figure><p></p><p>也就是默认的策略为轮询(RoundRobin)</p><p>看看其实现: <code>com.netflix.loadbalancer.RoundRobinRule#choose(ILoadBalancer, Object)</code>, 代码省略…</p><p>可以看到在该方法中调用了<code>ILoadBalancer#getAllServers</code>获取到服务列表, 通过一个线程安全的计数算法从中取出一个活着的Server返回</p><ul><li><p>继承结构</p><p><img src="https://blog-md-pic-1259135436.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/RoundRobinRule.png" alt="RoundRobinRule继承结构"></p></li></ul><p>从源码中可以看到IRule的实现有很多很多, 对应多种负载均衡策略的种类</p><p>网上有针对每种策略的解释, 不说了</p><p>至此, 已经分析了Ribbon从多个服务中依据某种负载策略选择一个进行调用</p><p>回答了开头问题1: <strong>Ribbon获取到服务列表后是如何负载? 如何路由到目标服务的?</strong></p><p><br></p><h3 id="获取-amp-更新服务"><a href="#获取-amp-更新服务" class="headerlink" title="获取 &amp; 更新服务"></a><strong>获取 &amp; 更新服务</strong></h3><p>下面来分析问题2: <strong>Ribbon是怎么获取/更新服务列表的?</strong></p><p>在consumer客户端进行第一次调用provider服务时, 能看到这样一行日志:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO c.n.l.DynamicServerListLoadBalancer      : DynamicServerListLoadBalancer for client cloudlink-user initialized: DynamicServerListLoadBalancer:&#123;</span><br><span class="line">	NFLoadBalancer:name=cloudlink-user,current list of Servers=[SC-201707142304:8801, SC-201707142304:8802],</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志中打印了服务提供者的信息</p><p>在源码中查看, 来自于<code>com.netflix.loadbalancer.DynamicServerListLoadBalancer#restOfInit</code>, 调用栈如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration#ribbonLoadBalancer</span><br><span class="line">		↓</span><br><span class="line">com.netflix.loadbalancer.ZoneAwareLoadBalancer#ZoneAwareLoadBalancer</span><br><span class="line">		↓</span><br><span class="line">com.netflix.loadbalancer.DynamicServerListLoadBalancer#DynamicServerListLoadBalancer</span><br><span class="line">		↓</span><br><span class="line">com.netflix.loadbalancer.DynamicServerListLoadBalancer#restOfInit</span><br></pre></td></tr></table></figure><p>最后在<code>restOfInit()</code>中调用了<code>updateListOfServers()</code>, 从字面意思看, 它与获取服务实例有关</p><ul><li><p><code>com.netflix.loadbalancer.DynamicServerListLoadBalancer#updateListOfServers</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@VisibleForTesting</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateListOfServers</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">	List&lt;T&gt; servers = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">	<span class="hljs-keyword">if</span> (serverListImpl != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">		servers = serverListImpl.getUpdatedListOfServers(); <span class="hljs-comment">// look me !</span></span><br><span class="line">		LOGGER.debug(<span class="hljs-string">"List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">				getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">		<span class="hljs-keyword">if</span> (filter != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">			servers = filter.getFilteredListOfServers(servers);</span><br><span class="line">			LOGGER.debug(<span class="hljs-string">"Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">					getIdentifier(), servers);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	updateAllServerList(servers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从这段代码能够推断出两点:</p><ul><li>获取到的服务集合信息<code>servers</code>来自于ServerList的实现类</li><li>ServerList接口中声明了获取服务列表的方法以及更新服务列表(30秒)的方法 —— 下面</li></ul><p>其实从上面那行debug日志已经能够看出服务列表信息来自于服务发现客户端</p><p>我们只需要进入ServerList的实现类证明即可</p><h4 id="ServerList"><a href="#ServerList" class="headerlink" title="ServerList"></a>ServerList</h4><p>这里看到了Ribbon中的另一个核心组件: ServerList 即服务列表, 用于获取地址列表</p><p>在与Spring Cloud Eureka集成的服务中, 它是从注册中心拉取的并能够动态更新的服务列表清单</p><p>当然, 在捕鱼Eureka集成的情况下可以配制成静态的地址列表</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServerList</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Server</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getInitialListOfServers</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Return updated list of servers. This is called say every 30 secs</span></span><br><span class="line"><span class="hljs-comment">     * (configurable) by the Loadbalancer's Ping cycle</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getUpdatedListOfServers</span><span class="hljs-params">()</span></span>;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到其实现: <code>com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList</code></p><p>可以看到以上两个方法的实现都调用了同一个方法<code>obtainServersViaDiscovery()</code></p><p>代码很长, 简化一下大致如下:<br></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DiscoveryEnabledServer&gt; serverList = <span class="hljs-keyword">new</span> ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line">EurekaClient eurekaClient = eurekaClientProvider.get();</span><br><span class="line">List&lt;InstanceInfo&gt; instanceInfo = eurekaClient.getInstancesByVipAddress(vipAddress, isSecure, targetRegion);</span><br><span class="line">serverList.add(<span class="hljs-keyword">new</span> DiscoveryEnabledServer(instanceInfo););</span><br></pre></td></tr></table></figure><p></p><p>还能看到在调用<code>getUpdatedListOfServers()</code>得到servers后, 并没有立即返回</p><p>而是又去执行了<code>filter.getFilteredListOfServers(servers);</code>过滤后返回</p><p><strong>至此, 已经能够证明Ribbon获取服务提供者的信息来自于Eureka Server</strong></p><h4 id="ServerListFilter"><a href="#ServerListFilter" class="headerlink" title="ServerListFilter"></a>ServerListFilter</h4><p>Ribbon中另一个组件: ServerListFilter, 负责服务列表过滤</p><p>仅当使用动态ServerList时使用, 用于在原始的服务列表中使用一定策略过虑掉一部分地址</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServerListFilter</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Server</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getFilteredListOfServers</span><span class="hljs-params">(List&lt;T&gt; servers)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的过滤器为<code>ZonePreferenceServerListFilter</code>, 会过滤出同区域的服务实例, 也就是区域优先</p><p>从ServerListFilter的实现类可以找到, Netflix Ribbon中还提供了其它的过滤规则, 不说了</p><h4 id="ServerListUpdater"><a href="#ServerListUpdater" class="headerlink" title="ServerListUpdater"></a>ServerListUpdater</h4><p>在DynamicServerListLoadBalancer中可以看到ServerListUpdater的定义</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ServerListUpdater.UpdateAction updateAction = </span><br><span class="line">    <span class="hljs-keyword">new</span> ServerListUpdater.UpdateAction() &#123;</span><br><span class="line">    	<span class="hljs-meta">@Override</span></span><br><span class="line">    	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doUpdate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">	        updateListOfServers();</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> ServerListUpdater serverListUpdater;</span><br></pre></td></tr></table></figure><p>它定义了服务列表ServerList的动态更新, 相当于一个服务更新器</p><ul><li>Implement 1(default): PollingServerListUpdater</li><li>Implement 2: EurekaNotificationServerListUpdater</li></ul><p>默认的动态更新策略为PollingServerListUpdater, 会执行一个定时任务, 源码中定义了默认执行周期为30s</p><h4 id="IPing"><a href="#IPing" class="headerlink" title="IPing"></a>IPing</h4><p>接口定义中只有一个方法, 检测服务是否活着</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IPing</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlive</span><span class="hljs-params">(Server server)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Ribbon中的默认实现为DummyPing, 也就是假Ping, 一直返回True</p><p>在与Eureka集成使用中, 默认实现为NIWSDiscoveryPing, 会根据服务实例的状态判断该实例是否活着:</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// ...</span></span><br><span class="line">InstanceStatus status = instanceInfo.getStatus();</span><br><span class="line"><span class="hljs-keyword">if</span> (status!=<span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">    isAlive = status.equals(InstanceStatus.UP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> isAlive;</span><br></pre></td></tr></table></figure><p>也是以定时任务周期执行, 源码可参考: <code>com.netflix.loadbalancer.BaseLoadBalancer.PingTask</code></p><p><br></p><h2 id="RestTemplate-amp-LB"><a href="#RestTemplate-amp-LB" class="headerlink" title="RestTemplate &amp; LB"></a>RestTemplate &amp; LB</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在Spring Cloud中的服务间通信场景, 除了可以使用声明式的REST客户端Feign, 也可以使用从Spring 3.0引入的RestTemplate</p><p>RestTemplate中封装了简单易用的API, 其实现默认是封装JDK原生的HTTP客户端URLConnection</p><p>如果你想替换实现为HttpClient, OkHttpClient, 加入对应的依赖和显示的配置即可, Spring Cloud已对其做好了自动配置</p><blockquote><p>参考: <code>org.springframework.cloud.commons.httpclient.HttpClientConfiguration</code></p></blockquote><p>例如替换为OkHttp3Client</p><ul><li><p>pom依赖</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>显示配置</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@LoadBalanced</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">	RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();</span><br><span class="line">    restTemplate.setRequestFactory(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());</span><br><span class="line">	<span class="hljs-keyword">return</span> restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那么问题来了, 服务间的调用和正常HttpClient远程调用还是有区别的</p><p>RestTemplate是如何具备从多个服务中挑选一个进行路由的能力? 它和Ribbon有什么关系?</p><p>我们知道, 有了<code>@LoadBalanced</code>注释, RestTemplate才能通过逻辑服务名的方式进行调用, 否则会是UnknowHostException</p><p>所以猜想RestTemplate在某一步会被赋予客户端负载的能力</p><p><br></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在LoadBalanced同路径下, 可以看到如下两个类:</p><ul><li>LoadBalancerAutoConfiguration</li><li>LoadBalancerInterceptor</li></ul><p>关注如下代码:<br></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-meta">@LoadBalanced</span></span><br><span class="line">	<span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)</span><br><span class="line">	<span class="hljs-keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">	<span class="hljs-meta">@Bean</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> SmartInitializingSingleton <span class="hljs-title">loadBalancedRestTemplateInitializerDeprecated</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">			<span class="hljs-keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="hljs-keyword">this</span>.restTemplates) &#123;</span><br><span class="line">                <span class="hljs-keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">                    customizer.customize(restTemplate); <span class="hljs-comment">// look me !</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line">		<span class="hljs-comment">//...</span></span><br><span class="line"></span><br><span class="line">		<span class="hljs-meta">@Bean</span></span><br><span class="line">		<span class="hljs-meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplateCustomizer <span class="hljs-title">restTemplateCustomizer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">			<span class="hljs-keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">                List&lt;ClientHttpRequestInterceptor&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(restTemplate.getInterceptors());</span><br><span class="line">                list.add(loadBalancerInterceptor); <span class="hljs-comment">// look me !</span></span><br><span class="line">                restTemplate.setInterceptors(list);</span><br><span class="line">            &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中最关键的就是<code>restTemplate.setInterceptors(list)</code>了, 为restTemplate添加了一个拦截器, 在发起HTTP请求时进行拦截</p><p><img src="https://blog-md-pic-1259135436.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/RestTemplate%20intercaptor.png" alt="RestTemplate#interceptors"></p><p>而拦截后要实现的功能肯定就是完成客户端负载, 进入该拦截器:<br></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line">	<span class="hljs-comment">//... </span></span><br><span class="line"></span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">			<span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">final</span> URI originalUri = request.getURI();</span><br><span class="line">		String serviceName = originalUri.getHost();</span><br><span class="line">		Assert.state(serviceName != <span class="hljs-keyword">null</span>, <span class="hljs-string">"Request URI does not contain a valid hostname: "</span> + originalUri);</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到intercept方法内传入了serviceName, request, 最终调用了<code>LoadBalancerClient#execute()</code></p><ul><li><p>其中host取到的是URL中填写的服务名</p><p>e.g. <code>http://cloudlink-user/priUser/getByIds</code>中服务名为<code>cloudlink-user</code></p></li><li><p>服务名serviceName取的是host</p></li></ul><p>那接下来就是根据serviceName, 根据负载找到一个服务实例进行路由, 又回到上面的 <strong>路由&amp;负载</strong> 过程啦</p><p>我们使用中都要使用@Bean对其初始化, 确保在启动时就初始化, 如果new一个, 用一段代码来简化手动模拟, 就是这个样子<br></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line"><span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">	RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();</span><br><span class="line">	List&lt;ClientHttpRequestInterceptor&gt; interceptors = restTemplate.getInterceptors();</span><br><span class="line">	interceptors.add(<span class="hljs-keyword">new</span> LoadBalancerInterceptor(loadBalancerClient));</span><br><span class="line">	restTemplate.setInterceptors(interceptors);</span><br><span class="line">	<span class="hljs-keyword">return</span> restTemplate.postForObject(<span class="hljs-string">"http://cloudlink-user/priUser/getByIds"</span>, userIds, List.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>源码没有很深入, 仅仅为了了解Ribbon工作流程和其中一些细节</p><p>整个流程还是比较清晰, 按照顺序大致分为:</p><ul><li>获取服务列表信息</li><li>执行定时任务动态更新/检查/剔除服务</li><li>对获取到的服务列表进行过滤</li><li>按照负载均衡策略在多个服务中选择一个服务进行调用</li></ul><p>从中也能看出, 在服务实例发生变化时, Consumer端并不能立刻感知到, 而是有一定的延迟, 可能会继续调用而报错</p><p>与Eureka相同, 再次看出CAP中保证了AP而适当牺牲C, 所以无论是服务网关路由到我们的服务, 还是服务消费者调用提供者.</p><p>作为Eureka Client调用侧, 尽可能的加入一定重试. 通过配置可以实现这一点</p></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://xiefayang.com/2019/04/23/源码分析——客户端负载Netflix Ribbon/">源码分析——客户端负载Netflix Ribbon</a></li><li><strong>本文作者：</strong><a href="https://xiefayang.com">i蝸居年華_谢谢谢</a></li><li><strong>本文链接：</strong><a href="https://xiefayang.com/2019/04/23/源码分析——客户端负载Netflix Ribbon/">https://xiefayang.com/2019/04/23/源码分析——客户端负载Netflix Ribbon/</a></li><li><strong>发布时间：</strong>2019-04-23</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"> <span class="is-size-6 has-text-grey has-mr-7">#</span> <a class="has-link-grey -link" href="/tags/微服务/">微服务</a></div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">坚持原创技术分享，您的支持将鼓励我继续创作！</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span> <span>支付宝</span><div class="qrcode"><img src="/images/no2.jpg" alt="支付宝"></div></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span> <span>微信</span><div class="qrcode"><img src="/images/no.gif" alt="微信"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/2019/04/26/Ribbon——超时与重试/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">Ribbon——超时与重试</span></a></div><div class="level-end"> <a class="level level-item has-link-grey article-nav-next" href="/2019/04/19/服务发现——需求与模式/"><span class="level-item">服务发现——需求与模式</span><i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="valine-thread" class="content"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="/js/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"yVPV2fAKC1B90Xnh2JjuPEAb-gzGzoHsz",app_key:"1i9DgF7j75Uq6OuM23etjjE9",placeholder:"Just go go, 支持Markdown~"})</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered"><div> <img class="image is-128x128 has-mb-6" src="/images/avatar.png" alt="i蝸居年華_谢谢谢" style="border-radius:50%"><p class="is-size-4 is-block"> i蝸居年華_谢谢谢</p><p class="is-size-6 is-block"> Just for fun</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Beijing, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading"> 文章</p><p class="title has-text-weight-normal"> 49</p></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading"> 分类</p><p class="title has-text-weight-normal"> 13</p></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading"> 标签</p><p class="title has-text-weight-normal"> 32</p></div></div></nav><div class="level"> <a class="level-item button is-link is-rounded" href="https://github.com/thank037" target="_blank">关注我</a></div><div class="level is-mobile"> <a class="level-item button is-white is-marginless" target="_blank" title="github" href="https://github.com/thank037" name><img src="/images/github.svg" style="width:20px;height:20px"></a> <a class="level-item button is-white is-marginless" target="_blank" title="gitee" href="https://gitee.com/thank037" name><img src="/images/gitee.svg" style="width:20px;height:20px"></a> <a class="level-item button is-white is-marginless" target="_blank" title="weibo" href="https://weibo.com/u/2139090054" name><img src="/images/weibo.svg" style="width:20px;height:20px"></a> <a class="level-item button is-white is-marginless" target="_blank" title="email" href="mailto:coderthank@163.com" name><img src="/images/email.svg" style="width:20px;height:20px"></a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label"> 文章目录</h3><ul class="menu-list"><li> <a class="is-flex" href="#前言"><span class="has-mr-6">1</span> <span>前言</span></a><ul class="menu-list"><li> <a class="is-flex" href="#目的"><span class="has-mr-6">1.1</span> <span>目的</span></a></li><li> <a class="is-flex" href="#说明"><span class="has-mr-6">1.2</span> <span>说明</span></a></li><li> <a class="is-flex" href="#核心组件"><span class="has-mr-6">1.3</span> <span>核心组件</span></a></li></ul></li><li> <a class="is-flex" href="#Ribbon核心源码"><span class="has-mr-6">2</span> <span>Ribbon核心源码</span></a><ul class="menu-list"><li> <a class="is-flex" href="#调试代码"><span class="has-mr-6">2.1</span> <span>调试代码</span></a></li><li> <a class="is-flex" href="#路由-amp-负载"><span class="has-mr-6">2.2</span> <span>路由 &amp; 负载</span></a><ul class="menu-list"><li> <a class="is-flex" href="#LoadBalancerClient"><span class="has-mr-6">2.2.1</span> <span>LoadBalancerClient</span></a></li><li> <a class="is-flex" href="#IRule"><span class="has-mr-6">2.2.2</span> <span>IRule</span></a></li></ul></li><li> <a class="is-flex" href="#获取-amp-更新服务"><span class="has-mr-6">2.3</span> <span>获取 &amp; 更新服务</span></a><ul class="menu-list"><li> <a class="is-flex" href="#ServerList"><span class="has-mr-6">2.3.1</span> <span>ServerList</span></a></li><li> <a class="is-flex" href="#ServerListFilter"><span class="has-mr-6">2.3.2</span> <span>ServerListFilter</span></a></li><li> <a class="is-flex" href="#ServerListUpdater"><span class="has-mr-6">2.3.3</span> <span>ServerListUpdater</span></a></li><li> <a class="is-flex" href="#IPing"><span class="has-mr-6">2.3.4</span> <span>IPing</span></a></li></ul></li></ul></li><li> <a class="is-flex" href="#RestTemplate-amp-LB"><span class="has-mr-6">3</span> <span>RestTemplate &amp; LB</span></a><ul class="menu-list"><li> <a class="is-flex" href="#介绍"><span class="has-mr-6">3.1</span> <span>介绍</span></a></li><li> <a class="is-flex" href="#源码分析"><span class="has-mr-6">3.2</span> <span>源码分析</span></a></li></ul></li><li> <a class="is-flex" href="#总结"><span class="has-mr-6">4</span> <span>总结</span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"> <a class="footer-logo is-block has-mb-6" href="/">i蝸居年華_谢谢谢</a><p class="is-size-7"> &copy; 2016—2021 i蝸居年華_谢谢谢&nbsp; 由<a href="http://hexo.io/" target="_blank">Hexo</a> 强力驱动<br> <span id="busuanzi_container_site_uv">您是第<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://github.com/thank037"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer="defer"></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer="defer"></script><script src="/js/gallery.js" defer="defer"></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer="defer"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer="defer"></script><script src="/js/clipboard.js" defer="defer"></script><script src="/js/main.js" defer="defer"></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"> <input type="text" class="searchbox-input ins-search-input" placeholder="全文搜索站内文章~"><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer="defer"></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300,mobile:{show:!0},react:{opacity:.7}},log:!1})</script></body></html>